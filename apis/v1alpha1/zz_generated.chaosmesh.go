// Copyright Chaos Mesh Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by chaos-builder. DO NOT EDIT.

package v1alpha1

import (
	"encoding/json"
	"reflect"
	"time"

	"github.com/pkg/errors"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"k8s.io/apimachinery/pkg/runtime"

	gw "github.com/chaos-mesh/chaos-mesh/api/genericwebhook"
)

// updating spec of a chaos will have no effect, we'd better reject it
var ErrCanNotUpdateChaos = errors.New("Cannot update chaos spec")

const KindJVMChaos = "JVMChaos"

// IsDeleted returns whether this resource has been deleted
func (in *JVMChaos) IsDeleted() bool {
	return !in.DeletionTimestamp.IsZero()
}

// IsPaused returns whether this resource has been paused
func (in *JVMChaos) IsPaused() bool {
	if in.Annotations == nil || in.Annotations[PauseAnnotationKey] != "true" {
		return false
	}
	return true
}

// GetObjectMeta would return the ObjectMeta for chaos
func (in *JVMChaos) GetObjectMeta() *metav1.ObjectMeta {
	return &in.ObjectMeta
}

// GetDuration would return the duration for chaos
func (in *JVMChaosSpec) GetDuration() (*time.Duration, error) {
	if in.Duration == nil {
		return nil, nil
	}
	duration, err := time.ParseDuration(string(*in.Duration))
	if err != nil {
		return nil, err
	}
	return &duration, nil
}

// GetStatus returns the status
func (in *JVMChaos) GetStatus() *ChaosStatus {
	return &in.Status.ChaosStatus
}

// GetSpecAndMetaString returns a string including the meta and spec field of this chaos object.
func (in *JVMChaos) GetSpecAndMetaString() (string, error) {
	spec, err := json.Marshal(in.Spec)
	if err != nil {
		return "", err
	}

	meta := in.ObjectMeta.DeepCopy()
	meta.SetResourceVersion("")
	meta.SetGeneration(0)

	return string(spec) + meta.String(), nil
}

// +kubebuilder:object:root=true

// JVMChaosList contains a list of JVMChaos
type JVMChaosList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []JVMChaos `json:"items"`
}

func (in *JVMChaosList) DeepCopyList() GenericChaosList {
	return in.DeepCopy()
}

// ListChaos returns a list of chaos
func (in *JVMChaosList) ListChaos() []GenericChaos {
	var result []GenericChaos
	for _, item := range in.Items {
		item := item
		result = append(result, &item)
	}
	return result
}

func (in *JVMChaos) DurationExceeded(now time.Time) (bool, time.Duration, error) {
	duration, err := in.Spec.GetDuration()
	if err != nil {
		return false, 0, err
	}

	if duration != nil {
		stopTime := in.GetCreationTimestamp().Add(*duration)
		if stopTime.Before(now) {
			return true, 0, nil
		}

		return false, stopTime.Sub(now), nil
	}

	return false, 0, nil
}

func (in *JVMChaos) IsOneShot() bool {
	return false
}

var JVMChaosWebhookLog = logf.Log.WithName("JVMChaos-resource")

func (in *JVMChaos) ValidateCreate() error {
	JVMChaosWebhookLog.Info("validate create", "name", in.Name)
	return in.Validate()
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (in *JVMChaos) ValidateUpdate(old runtime.Object) error {
	JVMChaosWebhookLog.Info("validate update", "name", in.Name)
	if !reflect.DeepEqual(in.Spec, old.(*JVMChaos).Spec) {
		return ErrCanNotUpdateChaos
	}
	return in.Validate()
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (in *JVMChaos) ValidateDelete() error {
	JVMChaosWebhookLog.Info("validate delete", "name", in.Name)

	// Nothing to do?
	return nil
}

var _ webhook.Validator = &JVMChaos{}

func (in *JVMChaos) Validate() error {
	errs := gw.Validate(in)
	return gw.Aggregate(errs)
}

var _ webhook.Defaulter = &JVMChaos{}

func (in *JVMChaos) Default() {
	gw.Default(in)
}

const KindPhysicalMachineChaos = "PhysicalMachineChaos"

// IsDeleted returns whether this resource has been deleted
func (in *PhysicalMachineChaos) IsDeleted() bool {
	return !in.DeletionTimestamp.IsZero()
}

// IsPaused returns whether this resource has been paused
func (in *PhysicalMachineChaos) IsPaused() bool {
	if in.Annotations == nil || in.Annotations[PauseAnnotationKey] != "true" {
		return false
	}
	return true
}

// GetObjectMeta would return the ObjectMeta for chaos
func (in *PhysicalMachineChaos) GetObjectMeta() *metav1.ObjectMeta {
	return &in.ObjectMeta
}

// GetDuration would return the duration for chaos
func (in *PhysicalMachineChaosSpec) GetDuration() (*time.Duration, error) {
	if in.Duration == nil {
		return nil, nil
	}
	duration, err := time.ParseDuration(string(*in.Duration))
	if err != nil {
		return nil, err
	}
	return &duration, nil
}

// GetStatus returns the status
func (in *PhysicalMachineChaos) GetStatus() *ChaosStatus {
	return &in.Status.ChaosStatus
}

// GetSpecAndMetaString returns a string including the meta and spec field of this chaos object.
func (in *PhysicalMachineChaos) GetSpecAndMetaString() (string, error) {
	spec, err := json.Marshal(in.Spec)
	if err != nil {
		return "", err
	}

	meta := in.ObjectMeta.DeepCopy()
	meta.SetResourceVersion("")
	meta.SetGeneration(0)

	return string(spec) + meta.String(), nil
}

// +kubebuilder:object:root=true

// PhysicalMachineChaosList contains a list of PhysicalMachineChaos
type PhysicalMachineChaosList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []PhysicalMachineChaos `json:"items"`
}

func (in *PhysicalMachineChaosList) DeepCopyList() GenericChaosList {
	return in.DeepCopy()
}

// ListChaos returns a list of chaos
func (in *PhysicalMachineChaosList) ListChaos() []GenericChaos {
	var result []GenericChaos
	for _, item := range in.Items {
		item := item
		result = append(result, &item)
	}
	return result
}

func (in *PhysicalMachineChaos) DurationExceeded(now time.Time) (bool, time.Duration, error) {
	duration, err := in.Spec.GetDuration()
	if err != nil {
		return false, 0, err
	}

	if duration != nil {
		stopTime := in.GetCreationTimestamp().Add(*duration)
		if stopTime.Before(now) {
			return true, 0, nil
		}

		return false, stopTime.Sub(now), nil
	}

	return false, 0, nil
}

func (in *PhysicalMachineChaos) IsOneShot() bool {
	return false
}

var PhysicalMachineChaosWebhookLog = logf.Log.WithName("PhysicalMachineChaos-resource")

func (in *PhysicalMachineChaos) ValidateCreate() error {
	PhysicalMachineChaosWebhookLog.Info("validate create", "name", in.Name)
	return in.Validate()
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (in *PhysicalMachineChaos) ValidateUpdate(old runtime.Object) error {
	PhysicalMachineChaosWebhookLog.Info("validate update", "name", in.Name)
	if !reflect.DeepEqual(in.Spec, old.(*PhysicalMachineChaos).Spec) {
		return ErrCanNotUpdateChaos
	}
	return in.Validate()
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (in *PhysicalMachineChaos) ValidateDelete() error {
	PhysicalMachineChaosWebhookLog.Info("validate delete", "name", in.Name)

	// Nothing to do?
	return nil
}

var _ webhook.Validator = &PhysicalMachineChaos{}

func (in *PhysicalMachineChaos) Validate() error {
	errs := gw.Validate(in)
	return gw.Aggregate(errs)
}

var _ webhook.Defaulter = &PhysicalMachineChaos{}

func (in *PhysicalMachineChaos) Default() {
	gw.Default(in)
}

const KindPhysicalMachine = "PhysicalMachine"

var PhysicalMachineWebhookLog = logf.Log.WithName("PhysicalMachine-resource")

func (in *PhysicalMachine) ValidateCreate() error {
	PhysicalMachineWebhookLog.Info("validate create", "name", in.Name)
	return in.Validate()
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (in *PhysicalMachine) ValidateUpdate(old runtime.Object) error {
	PhysicalMachineWebhookLog.Info("validate update", "name", in.Name)
	if !reflect.DeepEqual(in.Spec, old.(*PhysicalMachine).Spec) {
		return ErrCanNotUpdateChaos
	}
	return in.Validate()
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (in *PhysicalMachine) ValidateDelete() error {
	PhysicalMachineWebhookLog.Info("validate delete", "name", in.Name)

	// Nothing to do?
	return nil
}

var _ webhook.Validator = &PhysicalMachine{}

func (in *PhysicalMachine) Validate() error {
	errs := gw.Validate(in)
	return gw.Aggregate(errs)
}

var _ webhook.Defaulter = &PhysicalMachine{}

func (in *PhysicalMachine) Default() {
	gw.Default(in)
}

const KindStatusCheck = "StatusCheck"

var StatusCheckWebhookLog = logf.Log.WithName("StatusCheck-resource")

func (in *StatusCheck) ValidateCreate() error {
	StatusCheckWebhookLog.Info("validate create", "name", in.Name)
	return in.Validate()
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (in *StatusCheck) ValidateUpdate(old runtime.Object) error {
	StatusCheckWebhookLog.Info("validate update", "name", in.Name)
	if !reflect.DeepEqual(in.Spec, old.(*StatusCheck).Spec) {
		return ErrCanNotUpdateChaos
	}
	return in.Validate()
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (in *StatusCheck) ValidateDelete() error {
	StatusCheckWebhookLog.Info("validate delete", "name", in.Name)

	// Nothing to do?
	return nil
}

var _ webhook.Validator = &StatusCheck{}

func (in *StatusCheck) Validate() error {
	errs := gw.Validate(in)
	return gw.Aggregate(errs)
}

var _ webhook.Defaulter = &StatusCheck{}

func (in *StatusCheck) Default() {
	gw.Default(in)
}

func init() {

	SchemeBuilder.Register(&JVMChaos{}, &JVMChaosList{})
	all.register(KindJVMChaos, &ChaosKind{
		chaos: &JVMChaos{},
		list:  &JVMChaosList{},
	})

	SchemeBuilder.Register(&PhysicalMachineChaos{}, &PhysicalMachineChaosList{})
	all.register(KindPhysicalMachineChaos, &ChaosKind{
		chaos: &PhysicalMachineChaos{},
		list:  &PhysicalMachineChaosList{},
	})

	SchemeBuilder.Register(&PhysicalMachine{}, &PhysicalMachineList{})

	SchemeBuilder.Register(&StatusCheck{}, &StatusCheckList{})


	allScheduleItem.register(KindJVMChaos, &ChaosKind{
		chaos: &JVMChaos{},
		list:  &JVMChaosList{},
	})

	allScheduleItem.register(KindPhysicalMachineChaos, &ChaosKind{
		chaos: &PhysicalMachineChaos{},
		list:  &PhysicalMachineChaosList{},
	})

	allScheduleItem.register(KindWorkflow, &ChaosKind{
		chaos: &Workflow{},
		list:  &WorkflowList{},
	})

}
